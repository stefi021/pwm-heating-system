/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>


#include "stm32f4xx.h"
#include "led.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

void delay(uint32_t time) {
    for (uint32_t i = 0; i < time * 4000; i++) {
        __NOP(); // No Operation, samo da uspori
    }
}

void LED_Init(void)
{
    // 1. Enable GPIOA clock
    RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;

    // 2. Set PA5 as general purpose output
    GPIOA->MODER &= ~(3U << (5 * 2)); // Clear mode bits for PA5
    GPIOA->MODER |= (1U << (5 * 2));  // Set PA5 to Output mode (01)

    // 3. Optional: Set output type to push-pull (default)
    GPIOA->OTYPER &= ~(1U << 5);

    // 4. Optional: Set output speed (medium)
    GPIOA->OSPEEDR &= ~(3U << (5 * 2));
    GPIOA->OSPEEDR |= (1U << (5 * 2));

    // 5. Optional: Disable pull-up/pull-down
    GPIOA->PUPDR &= ~(3U << (5 * 2));
}

void SystemClock_Config(void)
{
    // 1. Enable HSE
    RCC->CR |= RCC_CR_HSEON;
    // Wait until HSE is ready
    while ((RCC->CR & RCC_CR_HSERDY) == 0);

    // 2. Set FLASH latency (2 wait states for 64 MHz)
    FLASH->ACR |= FLASH_ACR_LATENCY_2WS;

    // 3. Configure PLL
    RCC->PLLCFGR = (4 << RCC_PLLCFGR_PLLM_Pos) |   // PLLM = 4
                   (64 << RCC_PLLCFGR_PLLN_Pos) |  // PLLN = 64
                   (0 << RCC_PLLCFGR_PLLP_Pos) |   // PLLP = 2 (00b)
                   (RCC_PLLCFGR_PLLSRC_HSE);       // HSE as PLL source

    // 4. Enable PLL
    RCC->CR |= RCC_CR_PLLON;
    // Wait until PLL is ready
    while ((RCC->CR & RCC_CR_PLLRDY) == 0);

    // 5. Select PLL as system clock
    RCC->CFGR &= ~(RCC_CFGR_SW);
    RCC->CFGR |= RCC_CFGR_SW_PLL;
    // Wait until PLL is used as system clock
    while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_PLL);
}

// Initialize TIM5 to generate interrupt every 1 ms
void TIM5_Init(void)
{
    // Enable TIM5 clock
    RCC->APB1ENR |= RCC_APB1ENR_TIM5EN;

    // TIM5 is on APB1 (prescaler is x2 if HCLK>APB1 clock),
    // but default APB1 prescaler is /2 when HCLK > 42 MHz
    // In that case timer clock = APB1 clock x2 = 32MHz x 2 = 64MHz (perfect)

    TIM5->PSC = 64 - 1;   // Prescaler: (64 MHz / 64) = 1 MHz
    TIM5->ARR = 1000 - 1; // Auto-reload: (1 MHz / 1000) = 1 kHz -> 1 ms tick

    // Enable update interrupt
    TIM5->DIER |= TIM_DIER_UIE;

    // Enable TIM5 interrupt in NVIC
    NVIC_EnableIRQ(TIM5_IRQn);

    // Start the timer
    TIM5->CR1 |= TIM_CR1_CEN;
}

// Your timer 5 interrupt handler
volatile uint32_t msTicks = 0;
void TIM5_IRQHandler(void)
{
    if (TIM5->SR & TIM_SR_UIF)
    {
        TIM5->SR &= ~TIM_SR_UIF;
        msTicks++;
        if (msTicks == 500)
        {
            msTicks = 0;
            // Toggle LED ovde
            GPIOA->ODR ^= GPIO_ODR_OD5; // ako koristiš PA5 (na primer na Nucleo ploči)
        }
    }
}

int main(void) {
    SystemClock_Config();
    TIM5_Init();
    LED_Init();

//	INIT_GREEN_LED();

    while (1) {

    }
}
